Directory Structure
textfootball_game_web/
├── textfootball/
│   ├── __init__.py
│   ├── blueprints/
│   │   ├── __init__.py
│   │   ├── auth/
│   │   │   ├── __init__.py
│   │   │   └── routes.py
│   │   └── game/
│   │       ├── __init__.py
│   │       └── routes.py
│   ├── core/
│   │   ├── __init__.py
│   │   └── match_simulator.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── message.py
│   │   ├── player.py
│   │   ├── team.py
│   │   └── user.py
│   └── templates/
│       ├── balancing_workbench.html
│       ├── base.html
│       ├── coming_soon.html
│       ├── compose.html
│       ├── create_team.html
│       ├── dashboard.html
│       ├── index.html
│       ├── login.html
│       ├── mailbox.html
│       ├── match_result.html
│       ├── player_page.html
│       ├── register.html
│       ├── search.html
│       ├── simulate.html
│       ├── team_page.html
│       ├── user_profile.html
│       └── view_mail.html
├── instance/
│   └── database.db
├── tests/
│   ├── __init__.py
│   └── test_config.py
├── .gitignore
├── config.py
├── README.md
├── requirements.txt
└── run.py
File Breakdown
run.py: The main entry point to start the application. It imports the create_app factory from the textfootball package and the desired configuration from config.py, then runs the resulting Flask application.

config.py: A dedicated configuration file that defines settings for different environments (e.g., DevelopmentConfig, TestingConfig). This separates configuration from code, allowing for easy management of secret keys and database URIs for development, testing, and production.

instance/: A standard Flask folder for instance-specific data that should not be in version control.

database.db: The SQLite database file. Moving it here prevents it from being accidentally committed and keeps the main application package clean.

tests/: A dedicated package for all automated tests, keeping test code separate from application code for a clean and professional testing workflow.

textfootball/: The primary Python package containing all core application logic. It is organized into sub-packages for maximum clarity and scalability.

init.py: The application factory. This file contains the create_app() function which:

Initializes the Flask application.

Loads the appropriate configuration from the config.py object.

Initializes extensions like SQLAlchemy (db) and Flask-Migrate.

Imports and registers all blueprints from the textfootball.blueprints package.

Contains application-wide logic like context processors (e.g., for injecting the current team) and custom Jinja filters.

core/: A package for core business logic that is not directly related to web routes or database models. This decouples the "brains" of the application for easier testing and potential reuse.

match_simulator.py: The core simulation engine for the entire game. The engine is event-driven and deeply integrated with the Player Morale System. It blends open-play mechanics with a detailed Free Kick System and Penalty Kick System. After each match, it calculates and applies nuanced morale updates to every player based on the result, margin of victory/defeat, individual performance (e.g., goals scored), and player personality. It contains modes for both detailed single-match simulation (which saves morale changes) and high-speed Monte Carlo analysis (which does not).

models/: A package containing all SQLAlchemy database model definitions. The original models.py has been split into one file per model for improved organization and maintainability.

init.py: Gathers all models and enums from the separate files in the directory, making them easily importable from the textfootball.models namespace.

user.py: Defines the User model for account information.

team.py: Defines the Team model. Includes properties for calculating average squad morale (average_morale) and a field (last_meeting_date) to manage the cooldown for managerial interactions like team meetings.

player.py: Defines the Player model and related Enums (Position, Personality). This is the heart of the Player Morale System, defining player personality (e.g., Stoic, Volatile) and their current morale level. The crucial effective_skill property is dynamically calculated based on a player's base skill, current shape, and current morale, making team psychology a key factor in performance. It also contains attributes for penalty taking and saving.

message.py: Defines the Message model for private messages.

blueprints/: A package that organizes the application's routes into modular, feature-based blueprints.

auth/routes.py: A blueprint dedicated to all user authentication. Manages routes for /register, /login, and /logout.

game/routes.py: The main blueprint for all core gameplay features. It manages gameplay loops such as challenges, messaging, and team pages. It is the hub for managerial agency, featuring a Team Meeting system where managers can Praise, Encourage, or Criticize their squad with context-dependent outcomes that directly impact player morale. Starter squads are now generated with diverse personalities and morale values. The Balancing Workbench has been significantly upgraded to allow real-time editing of player morale and features a dedicated Morale Tuning panel to analyze the impact of system-wide parameter changes.

templates/: The directory containing all user-facing Jinja2 HTML templates for the application.

requirements.txt: A text file listing all the Python package dependencies required to run the project.